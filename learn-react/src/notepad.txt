import CourseItem from "./CourseItem.jsx";  /* import 시 확장자를 붙여도 안붙여도 무방하지만, 전자가 native ES Modules 사용 방법에 더 가까움 */


/* 컴포넌트에 return 에 소괄호가 없으면 이 다음 코드문장은 모두 무시가 됩니다. 반드시 작성
   jsx 문법에서 className으로 사용해야 함 (class로 사용시 오류 발생)
   필요시 HTML to JSX 변환 사이트 존재하므로 사용하기
*/
export default function CourseListCard() {
  return (
    <div className="card">
      ...
    </div>
  );
}

/* 함수 선언식 : 컴포넌트 상태, 로직인 경우 권유 */
/* 함수 선언식에 export default를 통해 최하단의 export default 생략 가능 */
export default function Counter() {  // ! 반드시 Pascal 함수명은 Case로 작성
    return (  // 컴포넌트 호출 시 Return 할 HTML 작성
        <button>Counter</button>
    )
}


/* 함수 표현식 : UI만 담당하는 경우 및 상태를 사용하지 않는 컴포넌트에 일반적으로 사용 */
/* 함수 표현식에 export를 사용함으로서 return 문 생략 가능 */
export const Counter = () => {
    // return ( // => return 문 생략 가능
      <button>Counter</button>
    // )
}


/* JSX */
    JSX는 JavaScript XML의 약어로, JS 확장 문법
    확장자를 .js .jsx하든 상관은 없지만, 리액트 컴포넌트에서는 JSX 문법을 사용하고 그안에서 HTML을 사용하기에 .jsx 사용 권장
    Vite로 빌드 한 경우는 파일 확장자에 따라 어떻게 처리할지 결정되기 때문에 .jsx 확장자가 필수

    규칙 1. 하나의 루트 엘리먼트로 반환하기
        오류 예제)
            return(
                <h1>...<h1>
                <h2>...<h2>
            )

        정상 예제)  만약 이때, div 태그를 랜더링 하지 않고 부모태그로 묶고싶다면 .. <> ... <> 와 같이 Fragment로 생략 가능
            return(
                <div>
                    ...
                </div>
            )

    규칙 2. 모든 태그는 닫아 주기

    규칙 3. 대부분 Camel Case 로 작성 하기

        JSX는 JS로 바뀌고 JSX에서 작성된 Attribute는 JS 객체 키가 되기 때문에, 컴포넌트에서 종종 Attribute를 변수로 읽고 싶은 경우가 있음.
        이 때, JS는 변수명에 제한이 있는데, -를 포험하거나 class처럼 예약어를 사용할 수 없기에 Camel Case로 작성하는 이유.
        예외) aria-*, data-*

    JSX 에서 자바스크립트 사용 return을 활용해 비즈니스 로직이 사용 가능

        export default function CourseItem(props) {

          const isEmpty = true;

          if (isEmpty) {
            return (
              <p>강의가 없습니다.</p>
            )
          }

          return (
            <article className="course">
              <img className="course__img" src="./img/htmlcss.png" alt="" />
              <div className="course__body">
                <div className="course__title">입문자를 위한, HTML&CSS 웹 개발 입문</div>
                <div className="course__description">웹 개발에 필요한 기본 지식을 배웁니다. </div>
              </div>
            </article>
          );
        }

    * 속성에 문자열 전달 : 작은따옴표나 큰따옴표로 묶어야 함
        export default function Avatar() {
          const avatar = 'https://i.imgur.com/7vQD0fPs.jpg';
          const description = 'Gregorio Y. Zara';
          return (
            <img
              className="avatar"
              src={avatar}
              alt={description}
            />
          );
        }

    * 마크업내에서 자바스크립트 사용
        const today = new Date();

        function formatDate(date) {
          return new Intl.DateTimeFormat(
            'en-US',
            { weekday: 'long' }
          ).format(date);
        }

        export default function TodoList() {
          return (
            <h1>To Do List for {formatDate(today)}</h1>
          );
        }

    * 중괄호 사용
        1. JSX 태그 안의 문자
            <h1>{name}'s To Do List</h1>                    : 동작
            <{tag}>Gregorio Y. Zara's To Do List</{tag}>    : 오류
            src={avatar}                                    : 동작
            src="{avatar}"                                  : 문자열 전달

        2. 이중 중괄호
            객체인 경우 중괄호를 감싸서 객체를 전달, 만약 인라인 스타일이 필요한 경우에도 (JSX에서는 인라인으로 style 선언하면 에러 발생함)
            style={{ backgroundColor: 'black', color: 'white' }}

            person={{ name: ‘짐코딩’, age: 20 }}
            <Component
            	person={{ name: '짐코딩', age: 20 }}
            />


/* import React from 'react' 에 대해서 */
    * JSX의 새로운 변환
    import React from 'react'; 를 사용하는 이유는 React 라이브러리 내에서 JSX를 컴파일 할 수 있도록 하기 위함이 가장 큰 이유.


    function Counter(props) {
        return (
            <div>
                count
            </div>
        );
    }

    는 다음과 같이 변환

    function Counter(props) {
        return React.createElement('div', null, 'count');
    }

    여기서 추가로 React 17 부터 JSX 트랜스 폼이 도입되며 더이상 React를 명시적으로 import할 필요가 없어졌음.

    주의) React 17 이하 버전인 경우 및 JSX 트랜스포 설정하지 않은 경우 import React from 'react'; 문장 필수 요소


/* 컴포넌트에 props 전달 */
리액트 컴포넌트는 props를 이용해 서로 통신
객체, 배열, 함수를 포함한 모든 JS 값 전달 가능

예시)
<img
  className="avatar"
  src="https://i.imgur.com/1bX5QH6.jpg"
  alt="Lin Lanying"
  width={100}
  height={100}
/>
이미지 태그에 전달할 수 있는 props는 미리 정의 되어있음.

하지만 개인이 생성한 어떤 컴포넌트는 props를 전달 가능.

function Avatar({ person, size }) {  // ...}

 * 구조분해 할당
function Avatar(props) {
	let person = props.person;
	let size = props.size;  // ...
}

* JSX spread 문법으로 props 전달하기
function Profile({ person, size, isSepia, thickBorder }) {
  return (
    <div className="card">
      <Avatar
        person={person}
        size={size}
        isSepia={isSepia}
        thickBorder={thickBorder}
      />
    </div>
  );
}

=>

function Profile(props) {
  return (
    <div className="card">
      <Avatar {...props} />     /* ...props내에 JS 전개구문과 유사하게 props 내부에 담겨있음 */
    </div>
  );
}



 * 유의사항
    이러한 **spread 문법은 제한적으로 사용하세요**. 다른 모든 컴포넌트에 이 구문을 사용한다면 문제가 있는 것입니다.

    1. **가독성 저하**: 코드가 읽기 어려워질 수 있어요. 어떤 속성이 어떤 값인지 바로 이해하기 힘들어질 수 있습니다.
    2. **버그 발생 가능성 증가**: 예기치 않은 속성이 전달될 수 있어요. 특히 많은 props가 있는 경우, 불필요한 속성이 전달될 위험이 커집니다.
    3. **리팩토링 어려움**: 컴포넌트를 분할하거나 재사용할 때, props를 명시적으로 전달하지 않으면 나중에 문제가 생길 수 있어요.


* 조건부 랜더링
조건분기시 랜더링을 원치 않는다면 null 반환
    ** 단락 평가
    앞에 연산결과를 고려하여 뒤에 평가 여부를 할지 말지 ..

    ex)
    result = "" && "foo";       // result 에 "" 할당
    result = 2 && 0;            // result 에 0 할당
    result = "foo" && 4;        // result 에 4 할당
